20:00

It starts!  Yay!

20:06

First commit.  Skeleton files, but whatever.

20:20

essen at Freenode recommended cowboy_examples as a quick to get up and
running Erlang program.  It rocks!  clone, make, ./start.sh and it's
up.  Now I have something to kill...

20:23

Stupid computer!  It rebooted from having a USB camera connected to
its USB port.  Happens every now and then.

Oh, well.  I'll head for Subway and get some food.

20:35

Sub acquired.

21:03

Program works.  I can go home.  :-)

Now let's make it a little bit more sophisticated.

22:00

It is fairly sophisticated at killing stuff.  The chaos monkey ignores
system processes, and will not do suicide.  Everything else is fair
bait.

Unfortunately it shouldn't really be allowed to kill supervisors,
because that breaks one of the Rules of Erlang.  Let's see if I can
identify those.

22:12

Well that was ten minutes of making my printouts nicer looking.  Hmm.

22:13

So, dear diary.  I never told you what the program is supposed to do.
Well it's a process killer.  I walks around in your system killing
random processes.  Just to see if you will recover.  What doesn't kill
you makes you stronger and all that.  Well, except in this case it's
"what kills you makes you stronger".  So now you know.

22:07

Support has been added for not killing supervisors.  Yay!

And I rewrote the whole printout thing.

I have no idea how to avoid killing the Erlang shell.

00:05

Speed of development has slowed down.

lists:filter(fun({P, App, S}) -> App =:= undefined end, [{P, application:get_application(P), pman_process:is_system_process(P)} || P <- erlang:processes()]).

00:30

Freenode #spawnfest rocks.  Once again very useful.  I did not know
about sys:get_status(whereis(chaos_monkey_sup)). before this.  Super.

I got tricked since I was so certain that supervisor was *not* a
gen_server.  Which it is of course.  Even though it shouldn't for so
many reasons.
